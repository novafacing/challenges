#include <dirent.h>
#include <errno.h>
#include <float.h>
#include <gmp.h>
#include <pwd.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <bsd/string.h>
#include <sys/stat.h>
/*
 * out of order listing, in a dir named "a", a file beginning with "f" will be out of order, so the "a" position in the bitmask should be "0xaf"
 */

#define MODULUS_SIZE 1024                   /* This is the number of bits we want in the modulus */
#define BLOCK_SIZE (MODULUS_SIZE/8)         /* This is the size of a block that gets en/decrypted at once */
#define BUFFER_SIZE ((MODULUS_SIZE/8) / 2)  /* This is the number of bytes in n and p */

typedef struct {
	mpz_t n; /* Modulus */
	mpz_t e; /* Public Exponent */
} public_key;

typedef struct {
	mpz_t n; /* Modulus */
	mpz_t e; /* Public Exponent */
	mpz_t d; /* Private Exponent */
	mpz_t p; /* Starting prime p */
	mpz_t q; /* Starting prime q */
} private_key;

void print_hex(char* arr, int len) {
	int i;
	for(i = 0; i < len; i++)
		printf("%02x", (unsigned char) arr[i]);
}

void block_encrypt(mpz_t C, mpz_t M, public_key kp) {
	/* C = M^e mod n */
	mpz_powm(C, M, kp.e, kp.n);
	return;
}

int encrypt(char cipher[], char message[], int length, public_key kp) {
	/* Its probably overkill, but I implemented PKCS#1v1.5 paging
	 * Encoded message block is of the form:
	 * EMB = 00 || 02 || PS || 00 || D
	 * Where || is concatenation, D is the message, and PS is a string of
	 * (block_size-|D|-3) non-zero, randomly generated bytes
	 * |D| must be less than block_size - 11, which means we have at least 8
	 * bytes of PS
	 */
	int block_count = 0;
	int prog = length;
	char mess_block[BLOCK_SIZE];
	mpz_t m; mpz_init(m);
	mpz_t c; mpz_init(c);

	while(prog > 0)
	{
		int i = 0;
		int d_len = (prog >= (BLOCK_SIZE - 11)) ? BLOCK_SIZE - 11 : prog;

		/* Construct the header */
		mess_block[i++] = 0x00;
		mess_block[i++] = 0x02;
		while(i < (BLOCK_SIZE - d_len - 1))
			mess_block[i++] = (rand() % (0xFF - 1)) + 1;
		mess_block[i++] = 0x00;

		/* Copy in the message */
		memcpy(mess_block + i, message + (length - prog), d_len);

		// Convert bytestream to integer
		mpz_import(m, BLOCK_SIZE, 1, sizeof(mess_block[0]), 0, 0, mess_block);
		// Perform encryption on that block
		block_encrypt(c, m, kp);

		// Calculate cipher write offset to take into account that we want to
		// pad with zeros in the front if the number we get back has fewer bits
		// than BLOCK_SIZE
		int off = block_count * BLOCK_SIZE;         // Base offset to start of this block
		off += (BLOCK_SIZE - (mpz_sizeinbase(c, 2) + 8 - 1)/8); // See manual for mpz_export

		// Pull out bytestream of ciphertext
		mpz_export(cipher + off, NULL, 1, sizeof(char), 0, 0, c);

		block_count++;
		prog -= d_len;
	}
	return block_count * BLOCK_SIZE;
}

void block_decrypt(mpz_t M, mpz_t C, private_key ku) {
	mpz_powm(M, C, ku.d, ku.n);
	return;
}

int decrypt(char* message, char* cipher, int length, private_key ku) {
	int msg_idx = 0;
	char buf[BLOCK_SIZE];
	*(long long*)buf = 0ll;
	mpz_t c; mpz_init(c);
	mpz_t m; mpz_init(m);

	int i;
	for(i = 0; i < (length / BLOCK_SIZE); i++)
	{
		// Pull block into mpz_t
		mpz_import(c, BLOCK_SIZE, 1, sizeof(char), 0, 0, cipher + i * BLOCK_SIZE);
		// Decrypt block
		block_decrypt(m, c, ku);

		// Calculate message write offset to take into account that we want to
		// pad with zeros in the front if the number we get back has fewer bits
		// than BLOCK_SIZE
		int off = (BLOCK_SIZE - (mpz_sizeinbase(m, 2) + 8 - 1)/8); // See manual for mpz_export
		// Convert back to bitstream
		mpz_export(buf + off, NULL, 1, sizeof(char), 0, 0, m);

		// Now we just need to lop off top padding before memcpy-ing to message
		// We know the first 2 bytes are 0x00 and 0x02, so manually skip those
		// After that, increment forward till we see a zero byte
		int j;
		for(j = 2; ((buf[j] != 0) && (j < BLOCK_SIZE)); j++);
		j++;        // Skip the 00 byte

		/* Copy over the message part of the plaintext to the message return var */
		memcpy(message + msg_idx, buf + j, BLOCK_SIZE - j);

		msg_idx += BLOCK_SIZE - j;
	}
	return msg_idx;
}

int TABLE[] = {
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	46,
	108,
	61,
	67,
	112,
	97,
	88,
	87,
	51,
	55,
	100,
	109,
	43,
	50,
	63,
	72,
	125,
	75,
	104,
	98,
	111,
	106,
	38,
	89,
	93,
	70,
	62,
	114,
	124,
	57,
	45,
	47,
	91,
	73,
	35,
	96,
	60,
	83,
	56,
	33,
	90,
	84,
	66,
	105,
	118,
	120,
	102,
	122,
	41,
	110,
	123,
	68,
	82,
	119,
	115,
	121,
	101,
	86,
	37,
	69,
	58,
	53,
	92,
	49,
	48,
	42,
	99,
	80,
	116,
	40,
	39,
	76,
	59,
	64,
	77,
	44,
	36,
	78,
	79,
	117,
	103,
	65,
	54,
	107,
	74,
	94,
	85,
	126,
	81,
	52,
	34,
	113,
	95,
	71,
	0};

extern char * optarg;
extern int optind, opterr;

extern int getopt(int argc, char * const argv[], 
		const char * optstring);

#define MAX_PATHS 100

typedef struct args {
	bool l;
	bool a;
	bool h;
	bool s;
	bool d;
	char ** paths;
	int path_count;
} args;

void free_dirs(args * options) {
	for (int i = 0; i < options->path_count; i++) {
		free(options->paths[i]);
	}
}

void free_css(char ** c, size_t num) {
	for (unsigned i = 0; i < num; i++) {
		free(c[i]);
	}
	free(c);
}


char * strrev(char * str) {
	char *p1, *p2;

	if (! str || ! *str) {
		return str;
	}
	for (p1 = str, p2 = str + strlen(str) - 1; p2 > p1; ++p1, --p2) {
		*p1 ^= *p2;
		*p2 ^= *p1;
		*p1 ^= *p2;
	}
	return str;
}

char * human_size(uint64_t size) {
	char * suffix[] = {"B", "KB", "MB", "GB", "TB", "PB", "EB"};
	char len = sizeof(suffix) / sizeof(suffix[0]);

	int i = 0;
	double db_bytes = size;
	if (size > 1024) {
		for (i = 0; (size / 1024) > 0 && i < len - 1; i++, size /= 1024) {
			db_bytes = size / 1024.0;
		}
	}
	char * h_size = (char *)calloc(6 + DBL_MANT_DIG - DBL_MIN_EXP, sizeof(char));
	sprintf(h_size, "%.02f %s", db_bytes, suffix[i]);
	return h_size;
}

int t_comp(const void * a, const void * b) {
	return strncmp(*(const char **)a, *(const char **)b, 1);
}

int sort_comparator(const void * a, const void * b) {
	const char * _a = *(const char **)a;
	const char * _b = *(const char **)b;
	char * remains_a = strrchr(_a, '/');
	char * remains_b = strrchr(_b, '/');
	char * fname = (char *)strndup(_a, remains_a - _a);
	char * basename_a = (char *)strndup(remains_a + 1, strchr(remains_a, ' ') - remains_a);
	char * basename_b = (char *)strndup(remains_b + 1, strchr(remains_b, ' ') - remains_b);
	if (basename_a != NULL && basename_b != NULL) {
		char misorder_char = fname[strlen(fname) - 1];
		char misorder = (char)TABLE[misorder_char % 128];
		//printf("%c\n", misorder);
		if (basename_a[0] != misorder && basename_b[0] != misorder) {
			int r = strcmp(basename_a, basename_b);
			//printf("comp %s %s\n", basename_a, basename_b);
			free(basename_a);
			free(basename_b);
			free(fname);
			return r;
		} else if (basename_a[0] == misorder && basename_b[0] != misorder) {
			strrev(basename_a);
			//printf("comp %s %s\n", basename_a, basename_b);
			int r = strcmp(basename_a, basename_b);
			free(basename_a);
			free(basename_b);
			free(fname);
			return r;
		} else if (basename_a[0] != misorder && basename_b[0] == misorder) {
			strrev(basename_b);
			//printf("comp %s %s\n", basename_a, basename_b);
			int r = strcmp(basename_a, basename_b);
			free(basename_a);
			free(basename_b);
			free(fname);
			return r;
		} else {
			strrev(basename_a);
			strrev(basename_b);
			//printf("comp %s %s\n", basename_a, basename_b);
			int r = strcmp(basename_b, basename_a);
			free(basename_a);
			free(basename_b);
			free(fname);
			return r;
		}
	} 
	free(basename_a);
	free(basename_b);
	free(fname);
	return 0;
}

int list_dirs(args * options) {
	for (int i = 0; i < options->path_count; i++) {
		errno = 0;
		struct dirent * dir;
		if (options->paths[i][strlen(options->paths[i]) - 1] != '/') {
			options->paths[i] = realloc(options->paths[i], strlen(options->paths[i]) + 2);
			strlcat(options->paths[i], "/", strlen(options->paths[i]) + 2);
		}
		int entry_count = 0;
		char ** entries = NULL;
		if (options->s) {
			DIR * check_d = opendir(options->paths[i]);
			struct dirent * check_dir;
			if (errno) {
				return 0;
			}
			if (check_d)  {
				while ((check_dir = readdir(check_d)) != NULL) {
					entry_count++;
				}
			}
			closedir(check_d);
			entries = (char **)calloc(entry_count, sizeof(char *));
		}
		entry_count = 0;
		DIR * d = opendir(options->paths[i]);
		if (errno) {
			return 0;
		}
		if (d) {
			while ((dir = readdir(d)) != NULL) {
				if (!options->a && dir->d_name[0] == '.') {
					continue;
				}
				char * fname = (char *)calloc(strlen(options->paths[i]) + 1, sizeof(char));
				strncpy(fname, options->paths[i], strlen(options->paths[i]));
				fname = realloc(fname, strlen(fname) + strlen(dir->d_name) + 1);
				strlcat(fname, dir->d_name, strlen(fname) + strlen(dir->d_name) + 1);
				if (!options->s) {
					printf("%s", fname);
				}
				if (options->l) {
					struct stat finfo;
					if (stat(fname, &finfo) == 0) {
						struct passwd * pinfo = getpwuid(finfo.st_uid);
						uint64_t size = finfo.st_size;
						if (options->h) {
							char * h_size = human_size(size);
							if (!options->s) {
								printf(" %s %s %o\n", h_size, pinfo->pw_name, finfo.st_mode);
							} else {
								entries[entry_count] = (char *)calloc(strlen(h_size) + strlen(fname) + strlen(pinfo->pw_name) + 9 + 10, sizeof(char)); 
								sprintf(entries[entry_count++], "%s %s %s %o", fname, h_size, pinfo->pw_name, finfo.st_mode);

							}
							free(h_size);
						} else {
							if (!options->s) {
								printf(" %ld %s %o\n", finfo.st_size, pinfo->pw_name, finfo.st_mode);
							} else {
								entries[entry_count] = (char *)calloc(strlen(fname) + 20 + strlen(pinfo->pw_name) + 9 + 10, sizeof(char));
								sprintf(entries[entry_count++], "%s %ld %s %o", fname, finfo.st_size, pinfo->pw_name, finfo.st_mode);
							}

						}
					} else if (options->s) {
						entries[entry_count] = (char *)calloc(strlen(fname) + 1, sizeof(char));
						strncpy(entries[entry_count++], fname, strlen(fname));
					}
				} else if (!options->s) {
					printf("\n");
				} else {
					entries[entry_count] = (char *)calloc(strlen(fname) + 1, sizeof(char));
					strncpy(entries[entry_count++], fname, strlen(fname));
				}
				free(fname);
			}
		} else {
			return 0;
		}
		closedir(d);
		if (errno) {
			return 0;
		}
		if (options->s) {
			qsort(entries, entry_count, sizeof(char *), sort_comparator);
			for (int i = 0; i < entry_count; i++) {
				//printf("%s\n", entries[i]);
			}
		}
	}
	return 1;
}

int main(int argc, char ** argv) {
	int opt;
	args * options = (args *)calloc(1, sizeof(args));
	options->l = false, options->a = false, options->h = false;
	options->paths = (char **)calloc(100, sizeof(char *));
	options->path_count = 0;
	while ((opt = getopt(argc, argv, ":lahsd")) != -1) {
		switch(opt) {
			case 'l': {
						  options->l = true;
						  break;
					  }
			case 'a': {
						  options->a = true;
						  break;
					  }
			case 'h': {
						  options->h = true;
						  break;
					  }
			case 's': {
						  options->s = true;
						  break;
					  }
			case 'd': {
						  options->d = true;
						  break;
					  }

		}
	}
	for (; optind < argc && optind < MAX_PATHS; optind++) {
		options->paths[options->path_count] = (char *)calloc(strlen(argv[optind]) + 1, sizeof(char));
		strncpy(options->paths[options->path_count++], argv[optind], strlen(argv[optind]));
	}
	if (!options->d) {
		list_dirs(options);
	} else {
		int map_count = 126 - 33;
		printf("There are about %d errors in this program. Figure out what the errors are and input them pair by pair on a line like so:\n", map_count);
		printf("<a:b><x:d>...\n");
		char * maps = (char *)calloc(5 * map_count + 1, sizeof(char));
		fgets(maps, map_count * 5, stdin);
		char ** split_maps = (char **)calloc(map_count, sizeof(char *));
		for (int i = 0, j = 0; i < 5 * map_count; i+= 5, j++) {
			split_maps[j] = (char *)calloc(3, sizeof(char));
			split_maps[j][0] = maps[i + 1];
			split_maps[j][1] = maps[i + 3];
		}
		qsort(split_maps, map_count, sizeof(char *), t_comp);
		char * i_str = (char *)calloc(3 * (2 * map_count) + 1, sizeof(char));
		for (int i = 0, j = 0; i < map_count; i++, j += 6) {
			sprintf(&i_str[j], "%03d", split_maps[i][0]);
			sprintf(&i_str[j + 3], "%03d", split_maps[i][1]);
		}

		char * r_str = strdup(i_str);
		strrev(r_str);

		mpz_t M;  
		mpz_t phi;
		mpz_t tmp1;
		mpz_t tmp2;
		mpz_t C;  
		mpz_t DC;  

		mpz_init(M);
		mpz_init(C);
		mpz_init(DC);

		private_key ku;
		public_key kp;

		// Initialize public key
		mpz_init(kp.n);
		mpz_init(kp.e);
		// Initialize private key
		mpz_init(ku.n);
		mpz_init(ku.e);
		mpz_init(ku.d);
		mpz_init(ku.p);
		mpz_init(ku.q);
		mpz_init(phi);
		mpz_init(tmp1);
		mpz_init(tmp2);

		mpz_set_ui(ku.e, 65537);

		mpz_init_set_str(tmp1, i_str, 10);
		mpz_nextprime(ku.p, tmp1);
		mpz_mod(tmp2, ku.p, ku.e);
		while (!mpz_cmp_ui(tmp2, 1)) {
			mpz_nextprime(ku.p, ku.p);
			mpz_mod(tmp2, ku.p, ku.e);
		}

		do {
			mpz_init_set_str(tmp1, r_str, 10);
			mpz_nextprime(ku.q, tmp1);
			mpz_mod(tmp2, ku.q, ku.e);
			while (!mpz_cmp_ui(tmp2, 1)) {
				mpz_nextprime(ku.q, ku.q);
				mpz_mod(tmp2, ku.q, ku.e);
			}
		} while (mpz_cmp(ku.p, ku.q) == 0);

		mpz_mul(ku.n, ku.p, ku.q);

		mpz_sub_ui(tmp1, ku.p, 1);
		mpz_sub_ui(tmp2, ku.q, 1);
		mpz_mul(phi, tmp1, tmp2);

		if (mpz_invert(ku.d, ku.e, phi) == 0) {
			mpz_gcd(tmp1, ku.e, phi);
			//printf("gcd(e, phi) = [%s]\n", mpz_get_str(NULL, 16, tmp1));
			//printf("Invert failed.\n");
		}
		mpz_set(kp.e, ku.e);
		mpz_set(kp.n, ku.n);

		//printf("---------------Private Key-----------------");
		//printf("kp.n is [%s]\n", mpz_get_str(NULL, 16, kp.n));
		//printf("kp.e is [%s]\n", mpz_get_str(NULL, 16, kp.e));
		//printf("---------------Public Key------------------");
		//printf("ku.n is [%s]\n", mpz_get_str(NULL, 16, ku.n));
		//printf("ku.e is [%s]\n", mpz_get_str(NULL, 16, ku.e));
		//printf("ku.d is [%s]\n", mpz_get_str(NULL, 16, ku.d));
		//printf("ku.p is [%s]\n", mpz_get_str(NULL, 16, ku.p));
		//printf("ku.q is [%s]\n", mpz_get_str(NULL, 16, ku.q));

		//char * plain = "b0ctf{shr3k_1s_l0ve_4nd_life}";
		char * enc = "437fe8818f85f39be92f4279dcc720bfc3973f3e1528d5d07efbc38fb41bfcc0270928b2a55ac4a0eeee820d2676fe5105df41af7f5e68e40a7b262870e25756ca34d146c676119955efc98fb1bf2399845547b121a8b0add0d00924e2dc2e89fbcecec18dde2b13feee07bab99b92e778ef6b9f95af1a936f1de96c517998ffaf0e4cac2d05568d84ef66fd1f84804084a5c9a0a70f9476001478edaacfc73d22c643079a497c69b69dcad691e856559aaca5cb2bff988c1d5da2aa99039e2f510b50db66e2e8933a5351bfdd459f3a29965b3d3f8d5686dbfeeccf155b4bd826795c79bfbbc1db25faa63e73469c032e7656062d4178d18a80ceea0cde8960a987d68c0a0640a8420006802cf6b11e3e88a06eee827dbe54c65fbeaa5ebe9c8cf09ad071a8d3dc0e1925b8d30002e8cd3792e7b0ba4d5b4184e83de264120a1cb9127f1cee7bdecf1670af561158769796dd7b977d427b5214b27f34e01eb1c3d7afef29ccb8a861740ebfcf1c9348f4d9e20c1cba9b87b5e98c3970f3899099dd54646684794b5a31cb65da1e873197b64d1496baf64242d2c7a51e8b345f06c912a860fe92a8fcb";
		//mpz_import(M, strlen(plain), 1, 1, 0, 0, plain);
		//printf("original is [%s]\n", mpz_get_str(NULL, 16, M));
		//block_encrypt(C, M, kp);
		mpz_init_set_str(C, enc, 16);
		//printf("encrypted is [%s]\n", mpz_get_str(NULL, 16, C));
		block_decrypt(DC, C, ku);
		//printf("decrypted is [%s]\n", mpz_get_str(NULL, 16, DC));
		char dec_buffer[4096];
		mpz_export(dec_buffer, NULL, 1, 1, 0, 0, DC);
		printf("%s\n", dec_buffer);
		printf("\n");
		free_css(split_maps, map_count);
		free(maps);
	}
	free_dirs(options);
	free(options->paths);
	free(options);
}
